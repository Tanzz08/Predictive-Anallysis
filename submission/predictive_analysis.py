# -*- coding: utf-8 -*-
"""Predictive Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hEUyQqgmn7LuZfIyftW7TqLuJXitD0DD

# Import Library
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline
import seaborn as sns

# Library yang sering digunakan
import os, shutil
import zipfile
import random
from random import sample
import shutil
from shutil import copyfile
import pathlib
from pathlib import Path
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from tqdm.notebook import tqdm as tq # untuk menampilkna bar progres saat proses iterasi

# Untuk menonaktifkan warinig yang mungkin muncul, seperti FutureWarning
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

# Menggunakan Google Colab
!nvidia-smi

"""# Data Loading"""

df = pd.read_csv('housePrice_makassar_from_rumah123.csv')
df

"""# Exploratory Data Analysis

**Deskripsi Variabel**

- Title : Judul iklan yang diberikan kepada promotor.
- Lokasi : lokasi rumah yang ditawarkan.
- Jumlah Kamar Tidur : jumlah kamar tidur yang direpresentasikan dalam bentuk integer
- Jumlah Kamar Mandi : jumlah kamar mandi yang direpresentasikan dalam bentuk integer
- Luas Tanah : luas tanah yang direpresentasikan dalam satuan m²
- Luas Bangunan : luas bangunan yang direpresentasikan dalam satuan m²
- Car Port : merepresentasikan atau mengindikasikan tempat parkir beratap terbuka atau semi terbuka
- Price : Harga rumah
- Timestamp : waktu saat berhasil mendapatkan data dari hasil scraping
"""

# Mengecek informasi pada dataset
df.info()

# Mengecek deskripsi statistik
df.describe()

df[df.Price == df.Price.min()]

df[df['Luas Tanah'] == df['Luas Tanah'].max()]

df[df['Luas Bangunan'] == df['Luas Bangunan'].max()]

df[df['Jumlah Kamar Mandi'] == df['Jumlah Kamar Mandi'].max()]

df[df['Jumlah Kamar Tidur'] == df['Jumlah Kamar Tidur'].max()]

"""## Mengecek Outliers"""

# Mengecek ouliers

numeric_cols = df.select_dtypes(include=np.number)
plt.figure(figsize=(20, 15))

for i, (label, data) in enumerate(numeric_cols.items(), 1):
    plt.subplot(6, 5, i)
    sns.boxplot(x=data, color='teal')
    plt.title(f"Boxplot {label}")
    plt.xlabel(label)

plt.tight_layout()
plt.show()

"""Outliers merupakan data anomali seperti yang ada pada poin pertama. kali ini kita melakukan visualisasi menggunakan boxplot

## Univariate Analysis

### Numerical Features
"""

# Menghitung histogram
df.hist(bins=50, figsize=(20, 15))
plt.show()

"""Sebagian besar fitur memiliki distribusi skewed ke kanan. banyak outlier yang berpotensi mengganggu peforma model

### Multivariate Analysis

### Numerical Features
"""

# Mengamati hubungan antar fitur numerik dengan fungsi pairplot()
sns.pairplot(df, diag_kind='kde')
plt.show()

"""Fitur 'Jumlah Kamar Tidur', 'Jumlah Kamar Mandi', 'Luas Tanah', 'Luas Bangunan' memiliki korelasi terhadap 'Price' walaupun sedikit lemah dikarenakan masih banyak outliers."""

# mengevaluasi skor korelasi

plt.figure(figsize=(15, 10))
correlation_matrix = df[numeric_cols.columns].corr().round(2)

sns.heatmap(data=correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5)
plt.title("Correlation Matrix untuk Fitur Numerik", size=20)

"""Dapat dilihat 'Jumlah Kamar Tidur', 'Jumlah Kamar Mandi', 'Luas Tanah', 'Luas Bangunan' memiliki angka mendekati 1 terhadap 'Price' yang mengindikasikan adanya korelasi terhadap fitur tersebut.

# Data Preparation

## Menangani Outliers
"""

# Ambil hanya kolom numerikal
numeric_cols = df.select_dtypes(include='number').columns
# Hitung Q1, Q3, dan IQR hanya untuk kolom numerikal
Q1 = df[numeric_cols].quantile(0.25)
Q3 = df[numeric_cols].quantile(0.75)
IQR = Q3 - Q1
# Buat filter untuk menghapus baris yang mengandung outlier di kolom numerikal
filter_outliers = ~((df[numeric_cols] < (Q1 - 1.5 * IQR)) |
                    (df[numeric_cols] > (Q3 + 1.5 * IQR))).any(axis=1)
# Terapkan filter ke dataset asli (termasuk kolom non-numerikal)
df = df[filter_outliers]
# Cek ukuran dataset setelah outlier dihapus
df.shape

df.describe()

"""## Innaccurate Data"""

# Hitung rata-rata Price
mean_price = df['Price'].mean()

# Dapatkan indeks dari baris dengan nilai Price minimum
min_price_index = df[df['Price'] == df['Price'].min()].index[0]

# Imputasi nilai Price terendah dengan rata-rata
df.loc[min_price_index, 'Price'] = mean_price

df.describe()

"""## Split Dataset"""

drop_cols = ['Price', 'Timestamp', 'Title', 'Lokasi',]
X = df.drop(drop_cols, axis=1)
y = df['Price']

# Split dataset
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

"""## Standarisasi"""

# Standarisasi
from sklearn.preprocessing import StandardScaler

numerical_features = ['Jumlah Kamar Tidur', 'Jumlah Kamar Mandi', 'Luas Bangunan', 'Luas Tanah', 'Car Port']
scaler = StandardScaler()
scaler.fit(X_train[numerical_features])
X_train[numerical_features] = scaler.transform(X_train.loc[:, numerical_features])
X_train[numerical_features].head()

X_train[numerical_features].describe().round(4)

"""# Model Development"""

# siapkan dataframe untuk analisis model
models = pd.DataFrame(index=['train_mse', 'test_mse'],
                      columns=['KNN', 'RandomForest', 'Boosting'])

# Melatih model knn
from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import mean_squared_error

knn = KNeighborsRegressor(n_neighbors=10)
knn.fit(X_train, y_train)

models.loc['train_mse','knn'] = mean_squared_error(y_pred = knn.predict(X_train), y_true=y_train)

# Melatih model random forest
from sklearn.ensemble import RandomForestRegressor

# Buat model prediksi
RF = RandomForestRegressor(n_estimators=50, max_depth=16, random_state=55, n_jobs=-1)
RF.fit(X_train, y_train)

models.loc['train_mse', 'RandomForest'] = mean_squared_error(y_pred=RF.predict(X_train), y_true=y_train)

# Melatih model boosting
from sklearn.ensemble import AdaBoostRegressor

boosting = AdaBoostRegressor(learning_rate=0.05, random_state=55)
boosting.fit(X_train, y_train)
models.loc['train_mse', 'Boosting'] = mean_squared_error(y_pred=boosting.predict(X_train), y_true=y_train)

"""# Evaluasi Model"""

# Scaling terhadap fitur numerik pada X_test
X_test.loc[:, numerical_features] = scaler.transform(X_test[numerical_features])

# Buat variabel mse yang isinya adalah datafram nilai mse data train dan test pada masing masing algoritma
mse = pd.DataFrame(columns=['train', 'test'], index=['KNN', 'RF', 'Boosting'])

# Buat dictionary untuk setiap algoritma yang digunakan
model_dict = {'KNN': knn, 'RF':RF, 'Boosting':boosting}

# Hitung MSE masing masing algoritma pada data train dan test
for name, model in model_dict.items():
  mse.loc[name, 'train'] = mean_squared_error(y_true=y_train, y_pred=model.predict(X_train))/1e3
  mse.loc[name, 'test'] = mean_squared_error(y_true=y_test, y_pred=model.predict(X_test))/1e3

# panggil mse
mse

fig, ax = plt.subplots()
mse.sort_values(by='test', ascending=False).plot(kind='barh', ax=ax, zorder=3)
ax.grid(zorder=0)

# Menguji perdiksi
prediksi = X_test.iloc[:1].copy()
pred_dict = {'y_true':y_test[:1]}
for name, model in model_dict.items():
  pred_dict['prediksi_'+name] = model.predict(prediksi).round(1)

pd.DataFrame(pred_dict)

# Menguji prediksi untuk seluruh data X_test
prediksi = X_test.copy()
pred_dict = {'y_true': y_test}

for name, model in model_dict.items():
    pred_dict['prediksi_' + name] = model.predict(prediksi).round(1)

# Hasil prediksi dalam bentuk DataFrame
hasil_prediksi = pd.DataFrame(pred_dict)
hasil_prediksi.head()  # Tampilkan 5 baris pertama (opsional)